/*
 * anal.c
 *
 *  Created on: 16/01/2017
 *      Author: taras
 */
#include "xparameters.h"
#include "xqspips.h"

#define QSPI_DEVICE_ID	XPAR_XQSPIPS_0_DEVICE_ID
static XQspiPs QspiInstance;

void set(){

		int Status;
		u8 UniqueValue;
		int Count;
		int Page;
		XQspiPs_Config *QspiConfig;

		/*
		 * Initialize the QSPI driver so that it's ready to use
		 */
		QspiConfig = XQspiPs_LookupConfig(QspiDeviceId);
		if (NULL == QspiConfig) {
			return XST_FAILURE;
		}

		Status = XQspiPs_CfgInitialize(QspiInstancePtr, QspiConfig,
						QspiConfig->BaseAddress);
		if (Status != XST_SUCCESS) {
			return XST_FAILURE;
		}

		/*
		 * Perform a self-test to check hardware build
		 */
		Status = XQspiPs_SelfTest(QspiInstancePtr);
		if (Status != XST_SUCCESS) {
			return XST_FAILURE;
		}

		/*
		 * Initialize the write buffer for a pattern to write to the FLASH
		 * and the read buffer to zero so it can be verified after the read, the
		 * test value that is added to the unique value allows the value to be
		 * changed in a debug environment to guarantee
		 */
		for (UniqueValue = UNIQUE_VALUE, Count = 0; Count < PAGE_SIZE;
		     Count++, UniqueValue++) {
			WriteBuffer[DATA_OFFSET + Count] = (u8)(UniqueValue + Test);
		}
		memset(ReadBuffer, 0x00, sizeof(ReadBuffer));

		/*
		 * Set the prescaler for QSPI clock
		 */
		XQspiPs_SetClkPrescaler(QspiInstancePtr, XQSPIPS_CLK_PRESCALE_8);

		/*
		 * Set Manual Start and Manual Chip select options and drive the
		 * HOLD_B high.
		 */
		XQspiPs_SetOptions(QspiInstancePtr, XQSPIPS_FORCE_SSELECT_OPTION |
						     XQSPIPS_MANUAL_START_OPTION |
						     XQSPIPS_HOLD_B_DRIVE_OPTION);

		/*
		 * Assert the FLASH chip select.
		 */
		XQspiPs_SetSlaveSelect(QspiInstancePtr);

		FlashReadID();

		/*
		 * Erase the flash.
		 */
		FlashErase(QspiInstancePtr, TEST_ADDRESS, MAX_DATA);

		/*
		 * Write the data in the write buffer to the serial FLASH a page at a
		 * time, starting from TEST_ADDRESS
		 */
		for (Page = 0; Page < PAGE_COUNT; Page++) {
			FlashWrite(QspiInstancePtr, (Page * PAGE_SIZE) + TEST_ADDRESS,
				   PAGE_SIZE, WRITE_CMD);
		}

		/*
		 * Read from the flash in LQSPI mode.
		 */
		XQspiPs_SetOptions(QspiInstancePtr, XQSPIPS_LQSPI_MODE_OPTION |
						     XQSPIPS_HOLD_B_DRIVE_OPTION);

		Status = XQspiPs_LqspiRead(QspiInstancePtr, ReadBuffer, TEST_ADDRESS,
					   MAX_DATA);
		if (Status != XST_SUCCESS) {
			return XST_FAILURE;
		}

		/*
		 * Setup a pointer to the start of the data that was read into the read
		 * buffer and verify the data read is the data that was written
		 */
		for (UniqueValue = UNIQUE_VALUE, Count = 0; Count < MAX_DATA;
		     Count++, UniqueValue++) {
			if (ReadBuffer[Count] != (u8)(UniqueValue + Test)) {
				return XST_FAILURE;
			}
		}

		/*
		 * Initialize the write buffer for a pattern to write to the FLASH
		 * and the read buffer to zero so it can be verified after the read, the
		 * test value that is added to the unique value allows the value to be
		 * changed in a debug environment to guarantee
		 */
		for (UniqueValue = UNIQUE_VALUE, Count = 0; Count < PAGE_SIZE;
		     Count++, UniqueValue++) {
			WriteBuffer[DATA_OFFSET + Count] = (u8)(UniqueValue + Test);
		}
		memset(ReadBuffer, 0x00, sizeof(ReadBuffer));

		/*
		 * Set Auto Start and Manual Chip select options and drive the
		 * HOLD_B high.
		 */
		XQspiPs_SetOptions(QspiInstancePtr, XQSPIPS_FORCE_SSELECT_OPTION |
						     XQSPIPS_HOLD_B_DRIVE_OPTION);

		/*
		 * Erase the flash.
		 */
		FlashErase(QspiInstancePtr, TEST_ADDRESS, MAX_DATA);

		/*
		 * Write the data in the write buffer to the serial FLASH a page at a
		 * time, starting from TEST_ADDRESS
		 */
		for (Page = 0; Page < PAGE_COUNT; Page++) {
			FlashWrite(QspiInstancePtr, (Page * PAGE_SIZE) + TEST_ADDRESS,
				   PAGE_SIZE, WRITE_CMD);
		}

		/*
		 * Read from the flash in LQSPI mode.
		 */
		XQspiPs_SetOptions(QspiInstancePtr, XQSPIPS_LQSPI_MODE_OPTION |
						     XQSPIPS_HOLD_B_DRIVE_OPTION);

		Status = XQspiPs_LqspiRead(QspiInstancePtr, ReadBuffer, TEST_ADDRESS,
					   MAX_DATA);
		if (Status != XST_SUCCESS) {
			return XST_FAILURE;
		}

		/*
		 * Setup a pointer to the start of the data that was read into the read
		 * buffer and verify the data read is the data that was written
		 */
		for (UniqueValue = UNIQUE_VALUE, Count = 0; Count < MAX_DATA;
		     Count++, UniqueValue++) {
			if (ReadBuffer[Count] != (u8)(UniqueValue + Test)) {
				return XST_FAILURE;
			}
		}

		return XST_SUCCESS;




}

